V5

1. clicking a faq in the faq page will query the chatbot
2. ranked faq in admin panel includes everything that has been queried atleast twice
3. replaced analytics page in admin panel with manage queries page
4. replaced corrected button with resolved date button
5. responsive admin panel
6. add feeback page in flutter app and admin panel
7. langsmith dashboard

possible future features:
1. add search/filter functionality to manage queries
2. select multiple queries to mark as resolved simultaneously
3. group similar queries together ("dean of cbm" vs "who is cbm dean")

next:
1. allow users to submit feedback
2. find a way to start system without manually running uvicorn
3. find a way to access admin panel in other devices
4. make the system apk work on phone
5. change app name from gsu_chatbot_app to ChatBook AI

def load_embeddings_and_db():
    """Load embeddings and database"""
    try:
        # Load a sentence-transformer embedding model from HuggingFace
        embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
        
        # Load the Chroma vector database, stored in the "data/chroma_db" folder,
        # and connect it with the embedding model
        db = Chroma(persist_directory="data/chroma_db", embedding_function=embeddings)
        
        # Create a retriever from the Chroma DB
        # - search_type="mmr" means it uses Maximal Marginal Relevance (balances relevance & diversity)
        # - k=15 → return top 15 results
        # - fetch_k=35 → fetch 35 candidates before narrowing down
        # - lambda_mult=0.5 → balance between relevance and diversity
        retriever = db.as_retriever(search_type="mmr", search_kwargs={"k": 15, "fetch_k": 35, "lambda_mult": 0.5})
        
        # Print confirmation if everything loads fine
        print("✅ Database loaded successfully")
        
        # Return embeddings, database, and retriever so other functions can use them
        return embeddings, db, retriever
    
    except Exception as e:
        # Handle any error during database loading and print the issue
        print(f"Database loading error: {e}")
        return None, None, None  # Return empty placeholders if something fails


def setup_admin_routes(app, memory, LOG_FILE, MEMORY_DB):
    @app.get("/admin", response_class=HTMLResponse)
    async def admin_dashboard(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        # Admin dashboard view (requires authentication)

        total_custom_info = len(memory.custom_info)

        # Load log data for statistics
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                reader = list(csv.DictReader(f))

            total_queries = len(reader)
            
            # Simple count based on CSV answered field
            answered_count = sum(1 for r in reader if (r.get("answered") or "").strip().lower() in ["true", "1", "yes"])
            not_answered_count = total_queries - answered_count
            accuracy_rate = (answered_count / total_queries * 100) if total_queries > 0 else 0
            
            recent_queries = list(reversed(reader[-10:])) if reader else []
        except FileNotFoundError:
            total_queries = 0
            answered_count = 0
            not_answered_count = 0
            accuracy_rate = 0
            recent_queries = []

        # Get database counts
        conn = sqlite3.connect(MEMORY_DB)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM conversations")
        total_conversations = cursor.fetchone()[0]
        cursor.execute("SELECT COUNT(*) FROM sessions")
        total_sessions = cursor.fetchone()[0]
        conn.close()

        # Render dashboard HTML
        return HTMLResponse(content=get_updated_dashboard_html(
            total_queries, answered_count, not_answered_count, accuracy_rate,
            total_conversations, total_sessions, total_custom_info, recent_queries
        ))

    @app.get("/admin/custom-info", response_class=HTMLResponse)
    async def admin_custom_info(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        # Admin page for managing custom information
        return HTMLResponse(content=get_custom_info_html(memory.custom_info))

    @app.get("/admin/custom-info/add", response_class=HTMLResponse)
    async def admin_add_info_form(
        credentials: HTTPBasicCredentials = Depends(verify_admin),
        prefill_topic: str = None
    ):
        # Form to add custom info, optionally pre-filling a topic
        prefilled_topic = unquote(prefill_topic) if prefill_topic else ""
        return HTMLResponse(content=get_add_custom_info_form_html(prefilled_topic))

    @app.post("/admin/custom-info/add")
    async def admin_add_info(
        credentials: HTTPBasicCredentials = Depends(verify_admin),
        topic: str = Form(...),
        information: str = Form(...),
    ):
        # Handle submission of new custom info
        memory.add_custom_info(topic, information)
        return RedirectResponse(url="/admin/custom-info", status_code=303)
    
    @app.get("/admin/upload-handbook", response_class=HTMLResponse)
    async def admin_upload_handbook_form(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        handbook_path = "data/handbook.pdf"
        handbook_info = ""
        if os.path.exists(handbook_path):
            file_size = os.path.getsize(handbook_path)
            file_size_mb = file_size / (1024 * 1024)
            modified_time = datetime.fromtimestamp(os.path.getmtime(handbook_path))
            handbook_info = f"Current handbook: {file_size_mb:.2f} MB, last updated {modified_time.strftime('%Y-%m-%d %H:%M:%S')}"
        else:
            handbook_info = "No handbook currently uploaded"
    
        return HTMLResponse(content=get_upload_handbook_html(handbook_info))

    @app.post("/admin/upload-handbook")
    async def admin_upload_handbook(
        credentials: HTTPBasicCredentials = Depends(verify_admin),
        file: UploadFile = File(...)
    ):
        try:
            if not file.filename.lower().endswith('.pdf'):
                raise HTTPException(status_code=400, detail="Only PDF files are allowed")
        
            os.makedirs("data", exist_ok=True)
        
            handbook_path = "data/handbook.pdf"
            temp_path = "data/handbook_temp.pdf"
            backup_path = "data/handbook_backup.pdf"
        
            if os.path.exists(handbook_path):
                shutil.copy2(handbook_path, backup_path)
        
            with open(temp_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
        
            if os.path.getsize(temp_path) == 0:
                os.remove(temp_path)
                raise HTTPException(status_code=400, detail="Uploaded file is empty")
        
            shutil.move(temp_path, handbook_path)
        
            if os.path.exists(backup_path):
                os.remove(backup_path)
        
            return RedirectResponse(url="/admin/custom-info?upload=success", status_code=303)
        
        except HTTPException:
            raise
        except Exception as e:
            if os.path.exists(backup_path) and not os.path.exists(handbook_path):
                shutil.move(backup_path, handbook_path)
        
            if os.path.exists(temp_path):
                os.remove(temp_path)
        
            raise HTTPException(status_code=500, detail=f"Error uploading handbook: {str(e)}")

    @app.get("/admin/custom-info/delete/{info_id}")
    async def admin_delete_info(
        info_id: str,
        credentials: HTTPBasicCredentials = Depends(verify_admin)
    ):
        # Delete a custom info entry if it exists
        if info_id in memory.custom_info:
            del memory.custom_info[info_id]
            memory.save_custom_info()
        return RedirectResponse(url="/admin/custom-info", status_code=303)

    @app.get("/admin/faq", response_class=HTMLResponse)
    async def admin_faq(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        # Full FAQ page with all frequently asked questions

        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                reader = list(csv.DictReader(f))

            # Count frequency of ALL questions
            query_counter = Counter(
                (r.get("query_text") or "").strip().lower() for r in reader if r.get("query_text")
            )
        
            # Get questions asked at least twice, sorted by frequency
            frequent_questions = [(q, count) for q, count in query_counter.most_common() if count >= 2]

            # Build FAQ data for each frequent question
            faq_list = []
            for question, count in frequent_questions:
                # Get all log entries for this exact question
                question_entries = [r for r in reader if (r.get("query_text") or "").strip().lower() == question]
            
                # Count successful answers
                answered_count = 0
                for entry in question_entries:
                    answered_field = (entry.get("answered") or "").strip().lower()
                    if answered_field in ["true", "1", "yes"]:
                        answered_count += 1

                success_rate = (answered_count / count * 100) if count > 0 else 0

                faq_data = {
                    "question": question,
                    "total_asked": count,
                    "answered_count": answered_count,
                    "success_rate": success_rate
                }
                faq_list.append(faq_data)

        except FileNotFoundError:
            faq_list = []

        return HTMLResponse(content=get_full_faq_html(faq_list))
    
    @app.get("/admin/manage-queries", response_class=HTMLResponse)
    async def admin_manage_queries(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        """Manage Queries page - shows unresolved queries"""

        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                reader = list(csv.DictReader(f))

            # Get not-answered queries that aren't resolved
            not_answered_queries = []
            for record in reader:
                answered_field = (record.get("answered") or "").strip().lower()
                query_text = (record.get("query_text") or "").strip()
                resolved_date = (record.get("resolved_date") or "").strip()
            
                # Include if: not answered, not resolved, and has query text
                if (answered_field not in ["true", "1", "yes"] and 
                    query_text and 
                    not resolved_date):
                    not_answered_queries.append(record)
        
            # Count frequency
            not_answered_counter = Counter()
            for query in not_answered_queries:
                query_text = (query.get("query_text") or "").strip().lower()
                if query_text:
                    not_answered_counter[query_text] += 1
        
            all_needing_attention = not_answered_counter.most_common()
        
        except FileNotFoundError:
            all_needing_attention = []
        except Exception as e:
            print(f"Error in manage queries: {e}")
            all_needing_attention = []

        return HTMLResponse(content=get_manage_queries_with_resolved_html(all_needing_attention))
    
    @app.get("/admin/feedback", response_class=HTMLResponse)
    async def admin_feedback(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        """Admin page to view user feedback"""
    
        try:
            with open("data/feedback.csv", "r", encoding="utf-8") as f:
                reader = list(csv.DictReader(f))
        
            # Sort by timestamp (newest first)
            feedback_list = sorted(reader, key=lambda x: x.get('timestamp', ''), reverse=True)
        
            # Calculate stats
            total_feedback = len(feedback_list)
            if total_feedback > 0:
                ratings = [int(f.get('rating', 0)) for f in feedback_list if f.get('rating', '').isdigit()]
                avg_rating = sum(ratings) / len(ratings) if ratings else 0
                rating_distribution = Counter(ratings)
            else:
                avg_rating = 0
                rating_distribution = Counter()
            
        except FileNotFoundError:
            feedback_list = []
            total_feedback = 0
            avg_rating = 0
            rating_distribution = Counter()
    
        return HTMLResponse(content=get_feedback_html(feedback_list, total_feedback, avg_rating, rating_distribution))
    
    @app.post("/admin/mark-resolved")
    async def mark_query_resolved(
        request: Request,
        credentials: HTTPBasicCredentials = Depends(verify_admin),
        question: str = Form(...)
    ):
        """Mark all instances of a question as resolved by updating CSV"""
        try:
            # Read current CSV
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                reader = list(csv.DictReader(f))
        
            # Add resolved_date column if it doesn't exist
            fieldnames = reader[0].keys() if reader else []
            if 'resolved_date' not in fieldnames:
                fieldnames = list(fieldnames) + ['resolved_date']
        
            # Update all instances of this question
            today = datetime.now().strftime("%Y-%m-%d")
            updated_count = 0
        
            for record in reader:
                if record.get("query_text", "").strip().lower() == question.lower():
                    if not record.get("resolved_date", "").strip():  # Only update if not already resolved
                        record["resolved_date"] = today
                        updated_count += 1
                    elif "resolved_date" not in record:  # Handle old CSV format
                        record["resolved_date"] = today
                        updated_count += 1
        
            # Write updated CSV with resolved_date column
            if reader:
                with open(LOG_FILE, "w", newline="", encoding="utf-8") as f:
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(reader)
        
            print(f"Marked {updated_count} instances of '{question}' as resolved")
            return RedirectResponse(url="/admin/manage-queries", status_code=303)
        
        except Exception as e:
            print(f"Error marking query as resolved: {e}")
            return RedirectResponse(url="/admin/manage-queries", status_code=303)

    @app.get("/admin/export-data")
    async def admin_export_data(credentials: HTTPBasicCredentials = Depends(verify_admin)):
        # Export chatbot system data
        export_data = {
            "custom_info": memory.custom_info,
            "export_timestamp": datetime.now().isoformat()
        }

        return {
            "data": export_data,
            "filename": f"gsu_chatbot_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        }